"""
File Service - Сервис для работы с файлами
Сохранение макросов, создание DSL переменных, запуск макросов
"""

from pathlib import Path
from typing import Optional, Dict, Any
import datetime
import subprocess
import os

class FileService:
    """Сервис для работы с файлами проекта"""
    
    def __init__(self, project_root: Path):
        self.project_root = project_root
        self.macros_dir = project_root / "macros"
        self.production_dir = self.macros_dir / "production"
        self.dsl_variables_file = project_root / "templates" / "DSL_VARIABLES.txt"
        
        # Создаем папки если их нет
        self.production_dir.mkdir(parents=True, exist_ok=True)
    
    def save_macro_to_file(self, macro_code: str, filename: Optional[str] = None, 
                          description: str = "", platform: str = "Unknown") -> Dict[str, Any]:
        """
        Сохранение макроса в .atlas файл
        
        Args:
            macro_code: Код макроса
            filename: Имя файла (если None, генерируется автоматически)
            description: Описание макроса
            platform: Платформа (TikTok, YouTube, etc.)
            
        Returns:
            Dict с результатом операции
        """
        try:
            # Генерируем имя файла если не указано
            if not filename:
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                safe_platform = platform.lower().replace(" ", "_")
                filename = f"{safe_platform}_macro_{timestamp}.atlas"
            
            # Убеждаемся что расширение .atlas
            if not filename.endswith('.atlas'):
                filename += '.atlas'
            
            # Полный путь к файлу
            file_path = self.production_dir / filename
            
            # Создаем содержимое файла
            file_content = self._create_atlas_content(macro_code, description, platform)
            
            # Сохраняем файл
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(file_content)
            
            return {
                'success': True,
                'file_path': str(file_path),
                'filename': filename,
                'message': f"Макрос сохранен: {filename}"
            }
            
        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'message': f"Ошибка сохранения: {e}"
            }
    
    def _create_atlas_content(self, macro_code: str, description: str, platform: str) -> str:
        """Создание содержимого .atlas файла"""
        
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Извлекаем чистый код из markdown блока если он есть
        clean_code = self._extract_code_from_markdown(macro_code)
        
        content = f"""# Macro Atlas File
# Generated by Macro AI Master
# Date: {timestamp}
# Platform: {platform}
# Description: {description}

# ============================================================================
# MACRO CODE
# ============================================================================

{clean_code}

# ============================================================================
# METADATA
# ============================================================================
# Platform: {platform}
# Generated: {timestamp}
# Description: {description}
# Version: 1.0
"""
        return content
    
    def _extract_code_from_markdown(self, text: str) -> str:
        """Извлечение чистого кода из markdown блока"""
        
        lines = text.split('\n')
        code_lines = []
        in_code_block = False
        
        for line in lines:
            # Начало блока кода
            if line.strip() == '```' and not in_code_block:
                in_code_block = True
                continue
            
            # Конец блока кода
            if line.strip() == '```' and in_code_block:
                break
            
            # Если мы внутри блока кода, добавляем строку
            if in_code_block:
                code_lines.append(line)
            
            # Если это не markdown и не пустая строка, тоже добавляем
            elif (not line.startswith('**') and 
                  not line.startswith('✅') and 
                  not line.startswith('Используйте') and
                  line.strip()):
                code_lines.append(line)
        
        return '\n'.join(code_lines).strip()
    
    def run_macro(self, file_path: str) -> Dict[str, Any]:
        """
        Запуск макроса через macro_sequence.py
        
        Args:
            file_path: Путь к .atlas файлу
            
        Returns:
            Dict с результатом запуска
        """
        try:
            # Проверяем существование файла
            if not Path(file_path).exists():
                return {
                    'success': False,
                    'error': 'Файл не найден',
                    'message': f"Файл {file_path} не существует"
                }
            
            # Путь к atlas_runner.py (наш простой интерпретатор .atlas файлов)
            atlas_runner_path = self.project_root / "utils" / "atlas_runner.py"
            
            if not atlas_runner_path.exists():
                return {
                    'success': False,
                    'error': 'atlas_runner.py не найден',
                    'message': "Интерпретатор .atlas файлов не найден"
                }
            
            # Запускаем макрос через atlas_runner
            result = subprocess.run([
                'python3', str(atlas_runner_path), file_path
            ], capture_output=True, text=True, cwd=self.project_root)
            
            if result.returncode == 0:
                return {
                    'success': True,
                    'output': result.stdout,
                    'message': "Макрос запущен успешно"
                }
            else:
                return {
                    'success': False,
                    'error': result.stderr,
                    'output': result.stdout,
                    'message': f"Ошибка запуска макроса: {result.stderr}"
                }
                
        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'message': f"Ошибка запуска: {e}"
            }
    
    def create_dsl_variable(self, name: str, code: str, description: str) -> Dict[str, Any]:
        """
        Создание DSL переменной и добавление в DSL_VARIABLES.txt
        
        Args:
            name: Имя переменной
            code: Код переменной
            description: Описание
            
        Returns:
            Dict с результатом операции
        """
        try:
            # Читаем существующий файл
            existing_content = ""
            if self.dsl_variables_file.exists():
                with open(self.dsl_variables_file, 'r', encoding='utf-8') as f:
                    existing_content = f.read()
            
            # Создаем новую переменную
            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            new_variable = f"""
# ============================================================================
# {name} - {description}
# Generated: {timestamp}
# ============================================================================

${{{name}}}
{code}

"""
            
            # Добавляем к существующему содержимому
            updated_content = existing_content + new_variable
            
            # Сохраняем файл
            with open(self.dsl_variables_file, 'w', encoding='utf-8') as f:
                f.write(updated_content)
            
            return {
                'success': True,
                'variable_name': name,
                'message': f"DSL переменная '{name}' создана"
            }
            
        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'message': f"Ошибка создания переменной: {e}"
            }
    
    def get_saved_macros(self) -> list:
        """Получение списка сохраненных макросов"""
        try:
            macros = []
            
            if self.production_dir.exists():
                for atlas_file in self.production_dir.glob("*.atlas"):
                    # Читаем метаданные из файла
                    try:
                        with open(atlas_file, 'r', encoding='utf-8') as f:
                            content = f.read()
                        
                        # Извлекаем метаданные
                        metadata = self._extract_metadata(content)
                        
                        macros.append({
                            'filename': atlas_file.name,
                            'path': str(atlas_file),
                            'size': atlas_file.stat().st_size,
                            'modified': datetime.datetime.fromtimestamp(atlas_file.stat().st_mtime),
                            'platform': metadata.get('platform', 'Unknown'),
                            'description': metadata.get('description', ''),
                        })
                    except Exception as e:
                        print(f"⚠️ Ошибка чтения {atlas_file}: {e}")
            
            # Сортируем по дате изменения (новые сначала)
            macros.sort(key=lambda x: x['modified'], reverse=True)
            
            return macros
            
        except Exception as e:
            print(f"⚠️ Ошибка получения макросов: {e}")
            return []
    
    def _extract_metadata(self, content: str) -> Dict[str, str]:
        """Извлечение метаданных из содержимого .atlas файла"""
        metadata = {}
        
        lines = content.split('\n')
        for line in lines:
            line = line.strip()
            if line.startswith('# Platform:'):
                metadata['platform'] = line.replace('# Platform:', '').strip()
            elif line.startswith('# Description:'):
                metadata['description'] = line.replace('# Description:', '').strip()
            elif line.startswith('# Generated:'):
                metadata['generated'] = line.replace('# Generated:', '').strip()
        
        return metadata
    
    def copy_to_clipboard(self, text: str) -> bool:
        """Копирование текста в буфер обмена"""
        try:
            # Используем pbcopy на macOS
            process = subprocess.run(['pbcopy'], input=text, text=True)
            return process.returncode == 0
        except Exception as e:
            print(f"⚠️ Ошибка копирования: {e}")
            return False
    
    def open_file_in_editor(self, file_path: str) -> bool:
        """Открытие файла в системном редакторе"""
        try:
            subprocess.run(['open', file_path])
            return True
        except Exception as e:
            print(f"⚠️ Ошибка открытия файла: {e}")
            return False
